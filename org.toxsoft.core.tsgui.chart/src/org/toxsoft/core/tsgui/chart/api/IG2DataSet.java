package org.toxsoft.core.tsgui.chart.api;

import org.toxsoft.core.tslib.av.temporal.*;
import org.toxsoft.core.tslib.bricks.strid.*;
import org.toxsoft.core.tslib.bricks.time.*;
import org.toxsoft.core.tslib.coll.*;
import org.toxsoft.core.tslib.utils.*;
import org.toxsoft.core.tslib.utils.errors.*;

/**
 * Набор данных графика.
 * <p>
 * Представляет собой упорядоченную по времени последовательность отсчетов {@link ITemporalAtomicValue}.
 * 
 * @author vs
 * @author goga
 */
public interface IG2DataSet
    extends IStridable, ICloseable {

  /**
   * Возвращает отчеты из подготовленного набора, охватывающие интервал.
   * <p>
   * Если в наборе вообще нет подготовленных данных, возвращается пустой набор. Также пстой набор возвращается, если
   * самый ранны отчет в наборе находится после окончания инетрвала. в остальных случаях данные возвращаются так, чтобы
   * охватить интервал. Первый (и только первый) отчет в списке может иметь метку времени до и равный началу интервала
   * {@link ITimeInterval#startTime() aInterval.startTime()}. Аналогично, последний (и только последний) отчет в списке
   * может иметь метку времени после окончания интервала. Все остальные данные находятся внутри запрошенного интервала.
   * <p>
   * Интервал-аргумент должен содержаться внутри интервала подготовленных данных (то есть, интервала-аргумента
   * последнего вызова {@link #prepare(ITimeInterval)}).
   * 
   * @param aInterval {@link ITimeInterval} - запрашиваемый интервал времени отчетов
   * @return IList&lt;{@link ITemporalAtomicValue}&gt; - спиоск (возможно пустой) отчетов
   * @throws TsNullArgumentRtException аргумент = null
   */
  IList<ITemporalAtomicValue> getValues( ITimeInterval aInterval );

  /**
   * Подготавливает данные для последующего получения методом {@link #getValues(ITimeInterval)}.
   * <p>
   * После вызова этого метода гарантируется (естественно, если во внешнем источнике есть данные), что набор содержит в
   * себе данные за этот интервал (например, получил из внегней базы данных). Вне этого интервала наличие данныхз в
   * наборе не гарантируется.
   * 
   * @param aInterval {@link ITimeInterval} - запрашиваемый интервал времени отчетов
   * @throws TsNullArgumentRtException аргумент = null
   */
  void prepare( ITimeInterval aInterval );

  /**
   * Возвращает пару значений - ближайших соседей к переданному моменту времени.
   * <p>
   * Если переданному моменту времени соотвествует значение в наборе, то в качестве левого и правого объекта
   * возвращается это существующее значение. Если для переданного момента времени значение в наборе отсутсвует, то в
   * качестве левого объекта возвращается значение у которого момент времени наиболее близок к переданному, но не
   * превосходит его. А в качестве правого - значение, у которого метка времени яляется ближайшей к требуемому моенту
   * времени и превосходит его. Таким образом, возвращаемое значение представляет собой интервал внутри которого
   * находится требуемый момент времени.<br>
   * <b>На заметку:</b><br>
   * Если переданный момент времени находится вне диапазона текущих значений набора (младше самого первого или старше
   * самого последнего), то реализация данног метода можжет возвращать в качестве левого и правого объекта пары -
   * {@link ITemporalAtomicValue#NULL}<br>
   * <b>Мотивация:</b><br>
   * Существует необхожимость определения значения для произвольно указанного момента времени. Например, это нужно при
   * формировании значений для "визира". Так как для произвольного момента времени значение в наборе модет отсутсвовать,
   * то возвращается пара ближайших значений, временные метки которых образуют интервал, внутри которого находится
   * требуемый момент времени. Данная информация может быть использована для вычисления (аппроксимации) значения в
   * указанный момент времени.<br>
   * Sol++ 18 jan 2016
   * 
   * @param aTimeStamp - момент времени
   * @return Pair - пара значений, внутри временного интервала которых, находится переданный момент времени
   */
  Pair<ITemporalAtomicValue, ITemporalAtomicValue> locate( long aTimeStamp );

}
